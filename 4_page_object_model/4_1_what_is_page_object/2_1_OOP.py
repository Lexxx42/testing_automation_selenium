class Car:
    # создаем атрибуты класса
    car_count = 0

    @staticmethod
    def get_class_details():
        print("Это класс Car")

    # создаем методы класса
    def __str__(self):
        return "Car class Object"

    def start(self, name, make, model):
        print("Двигатель заведен")
        self.name = name
        self.make = make
        self.model = model
        Car.car_count += 1


class Square:
    @staticmethod
    def get_squares(a, b):
        return a * a, b * b


car_a = Car()
car_a.start("Corrola", "Toyota", 2015)
print(car_a.name)
# print(dir(car_a))  # Все методы.
print(car_a.car_count)

car_b = Car()
car_b.start("City", "Honda", 2013)
print(car_b.name)
print(car_b.car_count)

Car.get_class_details()

# Возврат множественных значений из метода

print(Square.get_squares(3, 5))

# Метод str

print(car_a)  # <__main__.Car object at 0x000001F3653B8CD0>


#     def __str__(self):
#         return "Car class Object"

# Car class Object

# Конструкторы

# class Car:
#
#     # создание атрибутов класса
#     car_count = 0
#
#     # создание методов класса
#     def __init__(self):
#         Car.car_count +=1
#         print(Car.car_count)

# Модификаторы доступа

# публичный — public;
# приватный — private;
# защищенный — protected.

# Доступ к переменным с модификаторами публичного доступа открыт из любой точки вне класса,
# доступ к приватным переменным открыт только внутри класса,
# и в случае с защищенными переменными, доступ открыт только внутри того же пакета.

# Для создания приватной переменной,
# вам нужно проставить префикс двойного подчеркивание __ с названием переменной.

# Для создания защищенной переменной,
# вам нужно проставить префикс из одного нижнего подчеркивания _ с названием переменной.
# Для публичных переменных, вам не нужно проставлять префиксы вообще.

class Car:
    def __init__(self):
        print("Двигатель заведен")
        self.name = "corolla"
        self.__make = "toyota"
        self._model = 1999


car_a = Car()
print(car_a.name)
# print(car_a.make)  # AttributeError: 'Car' object has no attribute 'make'
print(car_a._model)


# Мы рассмотрели большую часть основных концепций
# объектно-ориентированного программирования в предыдущих двух секциях.
# Теперь, поговорим о столбах объектно-ориентированного программирования:

# Полиморфизм;
# Наследование;
# Инкапсуляция.

# Наследование

# Наследование в объектно-ориентированном программировании
# очень похоже на наследование в реальной жизни,
# где ребенок наследует те или иные характеристики его родителей
# в дополнение к его собственным характеристикам.

# В объектно-ориентированном программировании, наследование означает отношение IS-A.
# Например, болид — это транспорт.
# Наследование это одна из самых удивительных концепций объектно-ориентированного программирования,
# так как оно подразумевает повторное использование.

# Основная идея наследования в объектно-ориентированном программировании заключается в том,
# что класс может наследовать характеристики другого класса.
# Класс, который наследует другой класс,
# называется дочерним классом или производным классом,
# и класс, который дает наследие, называется родительским, или основным.

# Создание класса Vehicle
class Vehicle:
    def vehicle_method(self):
        print("Это родительский метод из класса Vehicle")


# Создание класса Car, который наследует Vehicle
class Car(Vehicle):
    def car_method(self):
        print("Это метод из дочернего класса")


car_a = Car()
car_a.vehicle_method()  # Вызываем метод родительского класса
car_a.car_method()

# Множественное наследование Python
print('***')


# создаем класс Vehicle
class Vehicle:
    def vehicle_method(self):
        print("Это родительский метод из класса Vehicle")


# создаем класс Car, который наследует Vehicle
class Car(Vehicle):
    def car_method(self):
        print("Это дочерний метод из класса Car")


# создаем класс Cycle, который наследует Vehicle
class Cycle(Vehicle):
    def cycleMethod(self):
        print("Это дочерний метод из класса Cycle")


car_a = Car()
car_a.vehicle_method()  # вызов метода родительского класса
car_b = Cycle()
car_b.vehicle_method()  # вызов метода родительского класса

print('+++')


class Camera:
    def camera_method(self):
        print("Это родительский метод из класса Camera")


class Radio:
    def radio_method(self):
        print("Это родительский метод из класса Radio")


class CellPhone(Camera, Radio):
    def cell_phone_method(self):
        print("Это дочерний метод из класса CellPhone")


cell_phone_a = CellPhone()
cell_phone_a.camera_method()
cell_phone_a.radio_method()

# Полиморфизм

# Термин полиморфизм буквально означает наличие нескольких форм.
# В контексте объектно-ориентированного программирования,
# полиморфизм означает способность объекта вести себя по-разному.

# Полиморфизм в программировании реализуется через перегрузку метода, либо через его переопределение.

# Перегрузка метода
# Перегрузка метода относится к свойству метода вести себя по-разному,
# в зависимости от количества или типа параметров.
# Взглянем на очень простой пример перегрузки метода.

# Выполним следующий скрипт:
print('----')


# создаем класс Car
class Car:
    def start(self, a, b=None):
        if b is not None:
            print(a + b)
        else:
            print(a)


car_a = Car()
car_a.start(10)
car_a.start(10, 20)


# Переопределение метода

# Переопределение метода относится к наличию метода
# с одинаковым названием в дочернем и родительском классах.
# Определение метода отличается в родительском и дочернем классах, но название остается тем же.
# Давайте посмотрим на простой пример переопределения метода в Python.

# создание класса Vehicle
class Vehicle:
    def print_details(self):
        print("Это родительский метод из класса Vehicle")


# создание класса, который наследует Vehicle
class Car(Vehicle):
    def print_details(self):
        print("Это дочерний метод из класса Car")


# создание класса Cycle, который наследует Vehicle
class Cycle(Vehicle):
    def print_details(self):
        print("Это дочерний метод из класса Cycle")


# В скрипте выше, классы Cycle и Car наследуют класс Vehicle.
# Класс Vehicle содержит метод print_details(), который переопределен дочерним классом.
# Теперь, если вы вызовите метод print_details(),
# выдача будет зависеть от объекта, через который вызывается метод.
# Выполните следующий скрипт, чтобы понять суть на деле:

print('########')
car_a = Vehicle()
car_a.print_details()

car_b = Car()
car_b.print_details()

car_c = Cycle()
car_c.print_details()


# Инкапсуляция

# Инкапсуляция — это третий столп объектно-ориентированного программирования.
# Инкапсуляция просто означает скрытие данных.
# Как правило, в объектно-ориентированном программировании один класс не должен иметь
# прямого доступа к данным другого класса.
# Вместо этого, доступ должен контролироваться через методы класса.

# Чтобы предоставить контролируемый доступ к данным класса в Python,
# используются модификаторы доступа и свойства.
# Мы уже ознакомились с тем, как действуют модификаторы доступа.
# В этом разделе мы посмотрим, как действуют свойства.

# Предположим, что нам нужно убедиться в том,
# что модель автомобиля должна датироваться между 2000 и 2018 годом.
# Если пользователь пытается ввести значение меньше 2000 для модели автомобиля,
# значение автоматически установится как 2000,
# и если было введено значение выше 2018, оно должно установиться на 2018.
# Если значение находится между 2000 и 2018 — оно остается неизменным.
# Мы можем создать свойство атрибута модели, которое реализует эту логику.
# Взглянем на пример:

# создаем класс Car
class Car:

    # создаем конструктор класса Car
    def __init__(self, model):
        # Инициализация свойств.
        self.model = model

    # создаем свойство модели.
    @property
    def model(self):
        return self.__model

    # Сеттер для создания свойств.
    @model.setter
    def model(self, model):
        if model < 2000:
            self.__model = 2000
        elif model > 2018:
            self.__model = 2018
        else:
            self.__model = model

    def getCarModel(self):
        return "Год выпуска модели " + str(self.model)


car_a = Car(2088)
print(car_a.get_car_model())

# Свойство имеет три части.
# Вам нужно определить атрибут, который является моделью в скрипте выше.
# Затем, вам нужно определить свойство атрибута, используя декоратор @property.
# Наконец, вам нужно создать установщик свойства,
# который является дескриптором @model.setter в примере выше.

# Теперь, если вы попробуете ввести значение выше 2018 в атрибуте модели,
# вы увидите, что значение установлено на 2018.
# Давайте проверим это.
# Выполним следующий скрипт:
